<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>NovaChat Server</title>
    <script src="peerjs.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        #app {
            display: flex;
            flex-direction: column;
            height: 100%;
            padding: 20px;
            box-sizing: border-box;
        }

        #serverControls,
        #adminPanel {
            margin-bottom: 20px;
        }

        input[type="text"] {
            padding: 5px;
            margin-right: 5px;
        }

        button {
            padding: 5px 10px;
            background-color: #007bff;
            color: white;
            border: none;
            cursor: pointer;
        }

        button:hover {
            background-color: #0056b3;
        }

        #blockedWordsList {
            list-style-type: none;
            padding: 0;
        }

        #blockedWordsList li {
            margin-bottom: 5px;
        }
    </style>
</head>

<body>
    <div id="app">
        <h1>NovaChat Server</h1>
        <div id="serverControls">
            <h2>Server Controls</h2>
            <input type="text" id="serverId" placeholder="Enter server ID" />
            <button onclick="changeServerId()">Change Server ID</button>
            <p id="currentServerId"></p>
        </div>
        <div id="adminPanel">
            <h2>Admin Panel</h2>
            <h3>Blocked Words</h3>
            <input type="text" id="newBlockedWord" placeholder="Enter word to block" />
            <button onclick="addBlockedWord()">Add Blocked Word</button>
            <ul id="blockedWordsList"></ul>
        </div>
    </div>
    <script>
        let peer;
        let blockedWords = JSON.parse(localStorage.getItem("blockedWords")) || [];
        let accounts = JSON.parse(localStorage.getItem("accounts")) || {};
        function log(message, m2, m3) {
            console.log(message, m2, m3);
        }
        function removeNonQwertyKeys(input) {
            // Define the set of characters on a US QWERTY keyboard
            const qwertyChars = new Set(
                "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789`~!@#$%^&*()_+-=[]{}\\|;:'\",.<>/?"
            );

            // Use a regular expression to match any character not in the QWERTY set
            const nonQwertyRegex = new RegExp(
                `[^${Array.from(qwertyChars).join("")}]`,
                "g"
            );

            // Replace all QWERTY characters with an empty string
            return input.replace(nonQwertyRegex, "");
        }

        function initServer() {
            const serverId =
                localStorage.getItem("serverId") || "default-server-id";
            peer = new Peer(serverId);

            peer.on("open", (id) => {
                log("Server started with ID:", id);
                document.getElementById(
                    "currentServerId"
                ).textContent = `Current Server ID: ${id}`;
            });

            peer.on("connection", (conn) => {
                log("New client connected:", conn.peer);
                conn.on("data", (data) => {
                    handleClientData(conn, data);
                });
            });

            updateBlockedWordsList();
        }

        function handleClientData(conn, data) {
            switch (data.type) {
                case "chat":
                    broadcastMessage(conn.peer, filterMessage(data.message));
                    break;
                case "register":
                    registerAccount(conn, data.username, data.password);
                    break;
                case "login":
                    loginAccount(conn, data.username, data.password);
                    break;
            }
        }

        function registerAccount(conn, username, password) {
            var clusername = removeNonQwertyKeys(username);
            if (accounts[username]) {
                conn.send({
                    type: "register",
                    success: false,
                    message: "Username already exists",
                });
            } else if (username !== clusername) {
                conn.send({
                    type: "register",
                    success: false,
                    message:
                        "Your Username contains unuseable charecters (US Qwerty Keyboard symbols only)",
                });
            } else if (blockedWords.some((item) => username.includes(item))) {
                conn.send({
                    type: "register",
                    success: false,
                    message: "Your Username contains blocked words.",
                });
            } else {
                accounts[username] = { password: password };
                localStorage.setItem("accounts", JSON.stringify(accounts));
                conn.send({ type: "register", success: true });
            }
        }

        function loginAccount(conn, username, password) {
            if (accounts[username] && accounts[username].password === password) {
                conn.send({ type: "login", success: true });
            } else {
                conn.send({
                    type: "login",
                    success: false,
                    message: "Invalid username or password",
                });
            }
        }

        function changeServerId() {
            const newId = document.getElementById("serverId").value;
            if (newId) {
                localStorage.setItem("serverId", newId);
                Object.keys(peer.connections).forEach((conns) => {
                    conns = Object.entries(peer.connections);
                    conns.forEach((conn) => {
                        conn[1][0].send({
                            type: "chat",
                            sender: "{SERVER}",
                            message: `Server is closing down to change ID. New ID: ${newId}`,
                        });
                    });
                    peer.disconnect();
                    peer.destroy();
                    initServer();
                });
            }
        }

        function addBlockedWord() {
            const word = document
                .getElementById("newBlockedWord")
                .value.toLowerCase();
            if (word && !blockedWords.includes(word)) {
                blockedWords.push(word);
                localStorage.setItem("blockedWords", JSON.stringify(blockedWords));
                updateBlockedWordsList();
                document.getElementById("newBlockedWord").value = "";
            }
        }

        function removeBlockedWord(word) {
            blockedWords = blockedWords.filter((w) => w !== word);
            localStorage.setItem("blockedWords", JSON.stringify(blockedWords));
            updateBlockedWordsList();
        }

        function updateBlockedWordsList() {
            const list = document.getElementById("blockedWordsList");
            list.innerHTML = "";
            blockedWords.forEach((word) => {
                const li = document.createElement("li");
                li.textContent = word;
                const removeBtn = document.createElement("button");
                removeBtn.textContent = "Remove";
                removeBtn.onclick = () => removeBlockedWord(word);
                li.appendChild(removeBtn);
                list.appendChild(li);
            });
        }

        function filterMessage(message) {
            let filteredMessage = message;
            blockedWords.forEach((word) => {
                const regex = new RegExp(word, "gi");
                filteredMessage = filteredMessage.replace(
                    regex,
                    "*".repeat(word.length)
                );
            });
            return filteredMessage;
        }

        function broadcastMessage(sender, message) {
            Object.entries(peer.connections).forEach((conns) => {
                conns = Object.entries(peer.connections);

                conns.forEach((conn) => {
                    console.log(conn);
                    conn[1][0].send({
                        type: "chat",
                        sender: message.name,
                        message: message.text,
                    });
                });
            });
        }

        initServer();
    </script>
</body>

</html>